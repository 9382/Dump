<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">
	<Meta name="ExplicitAutoJoints">true</Meta>
	<External>null</External>
	<External>nil</External>
	<Item class="Folder" referent="RBX2BD3CFF42E954C5393A9AF0CD4594274">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">Studio Obfuscation Tools</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
		<Item class="Folder" referent="RBX31DA83315A924902A356AEB4F1138DB9">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<string name="Name">CLI Tools</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="Folder" referent="RBX784486656EE84510BAC358AA068E0A1A">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<string name="Name">Unobfuscated</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBXC2529042DF7C471DA55532161DC50D37">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<bool name="Disabled">true</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Init</string>
					<token name="RunContext">0</token>
					<string name="ScriptGuid">{6AD43D07-EC7B-437E-99A7-EA72625F16C7}</string>
					<ProtectedString name="Source"><![CDATA[local container = game:GetService("ServerScriptService")["Studio Obfuscation Tools"]

local Parser = require(container.LuaParser)
local ExecutorText = require(container.ExecutorText)

local Commands = {}

function Commands.Parse(Code)
	local s,r = Parser(Code)
	assert(s,r)
	print("Parsed code")
	return r
end

function Commands.Obfuscate(Target)
	if typeof(Target) == "Instance" then
		local ParsedContent = Commands.Parse(Target.Source)
		local NewScript = Instance.new(Target.ClassName,Target.Parent)
		NewScript.Name = Target.Name .. " (Obfuscated)"
		NewScript.Source = ExecutorText .. "([=[" .. ParsedContent .. "]=])()"
		print("Obfuscated script")
		return NewScript
	elseif type(Target) == "string" then
		print("Obfuscated string")
		return ExecutorText .. "([=[" .. Target .. "]=])()"
	else
		error("Obfuscate what exactly?")
	end
end

local CLI = container["CLI Tools"]
local oldstorage = CLI:FindFirstChild("Unobfuscated") or (function()
	local f = Instance.new("Folder",CLI)
	f.Name = "Unobfuscated"
end)()
function Commands.Replace(Target)
	local NewScript = Commands.Obfuscate(Target)
	NewScript.Name = Target.Name
	Target.Name = Target:GetFullName()
	Target.Parent = oldstorage
	print("Put in obfuscated")
end
function Commands.Unreplace(Target)
	local Real = oldstorage:FindFirstChild(Target:GetFullName())
	assert(Real,"No old script to retrieve")
	Real.Name = Target.Name
	Real.Parent = Target.Parent
	Target:Destroy()
	print("Swapped back")
end

_G._O = Commands]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
		</Item>
		<Item class="ModuleScript" referent="RBXC1F39554F18140A2B596575A334CBC3E">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">LuaParser</string>
				<string name="ScriptGuid">{EB10EB6A-4DBA-43A7-94C6-C77AEE90D2E6}</string>
				<ProtectedString name="Source"><![CDATA[
--
-- Minify.lua
--
-- A compilation of all of the neccesary code to Minify a source file, all into one single
-- script for usage on Roblox. Needed to deal with Roblox' lack of `require`.
--

function lookupify(tb)
	for _, v in pairs(tb) do
		tb[v] = true
	end
	return tb
end

function CountTable(tb)
	local c = 0
	for _ in pairs(tb) do c = c + 1 end
	return c
end

function PrintTable(tb, atIndent)
	if tb.Print then
		return tb.Print()
	end
	atIndent = atIndent or 0
	local useNewlines = (CountTable(tb) > 1)
	local baseIndent = string.rep('		', atIndent+1)
	local out = "{"..(useNewlines and '\n' or '')
	for k, v in pairs(tb) do
		if type(v) ~= 'function' then
			out = out..(useNewlines and baseIndent or '')
			if type(k) == 'number' then
				--nothing to do
			elseif type(k) == 'string' and k:match("^[A-Za-z_][A-Za-z0-9_]*$") then 
				out = out..k.." = "
			elseif type(k) == 'string' then
				out = out.."[\""..k.."\"] = "
			else
				out = out.."["..tostring(k).."] = "
			end
			if type(v) == 'string' then
				out = out.."\""..v.."\""
			elseif type(v) == 'number' then
				out = out..v
			elseif type(v) == 'table' then
				out = out..PrintTable(v, atIndent+(useNewlines and 1 or 0))
			else
				out = out..tostring(v)
			end
			if next(tb, k) then
				out = out..","
			end
			if useNewlines then
				out = out..'\n'
			end
		end
	end
	out = out..(useNewlines and string.rep('		', atIndent) or '').."}"
	return out
end

local WhiteChars = lookupify{' ', '\n', '\t', '\r'}
local EscapeLookup = {['\r'] = '\\r', ['\n'] = '\\n', ['\t'] = '\\t', ['"'] = '\\"', ["'"] = "\\'"}
local LowerChars = lookupify{'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 
	'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 
	's', 't', 'u', 'v', 'w', 'x', 'y', 'z'}
local UpperChars = lookupify{'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 
	'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 
	'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'}
local Digits = lookupify{'0', '1', '2', '3', '4', '5', '6', '7', '8', '9'}
local HexDigits = lookupify{'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 
	'A', 'a', 'B', 'b', 'C', 'c', 'D', 'd', 'E', 'e', 'F', 'f'}

local Symbols = lookupify{'+', '-', '*', '/', '^', '%', ',', '{', '}', '[', ']', '(', ')', ';', '#'}

local Keywords = lookupify{
	'and', 'break', 'continue', 'do', 'else', 'elseif',
	'end', 'false', 'for', 'function', 'goto', 'if',
	'in', 'local', 'nil', 'not', 'or', 'repeat',
	'return', 'then', 'true', 'until', 'while',
};

function LexLua(src)
	--token dump
	local tokens = {}

	local st, err = pcall(function()
		--line / char / pointer tracking
		local p = 1
		local line = 1
		local char = 1

		--get / peek functions
		local function get()
			local c = src:sub(p,p)
			if c == '\n' then
				char = 1
				line = line + 1
			else
				char = char + 1
			end
			p = p + 1
			return c
		end
		local function peek(n)
			n = n or 0
			return src:sub(p+n,p+n)
		end
		local function consume(chars)
			local c = peek()
			for i = 1, #chars do
				if c == chars:sub(i,i) then return get() end
			end
		end

		--shared stuff
		local function generateError(err)
			return error(">> :"..line..":"..char..": "..err, 0)
		end

		local function tryGetLongString()
			local start = p
			if peek() == '[' then
				local equalsCount = 0
				while peek(equalsCount+1) == '=' do
					equalsCount = equalsCount + 1
				end
				if peek(equalsCount+1) == '[' then
					--start parsing the string. Strip the starting bit
					for _ = 0, equalsCount+1 do get() end

					--get the contents
					local contentStart = p
					while true do
						--check for eof
						if peek() == '' then
							generateError("Expected `]"..string.rep('=', equalsCount).."]` near <eof>.", 3)
						end

						--check for the end
						local foundEnd = true
						if peek() == ']' then
							for i = 1, equalsCount do
								if peek(i) ~= '=' then foundEnd = false end
							end 
							if peek(equalsCount+1) ~= ']' then
								foundEnd = false
							end
						else
							foundEnd = false
						end
						--
						if foundEnd then
							break
						else
							get()
						end
					end

					--get the interior string
					local contentString = src:sub(contentStart, p-1)

					--found the end. Get rid of the trailing bit
					for i = 0, equalsCount+1 do get() end

					--get the exterior string
					local longString = src:sub(start, p-1)

					--return the stuff
					return contentString, longString
				else
					return nil
				end
			else
				return nil
			end
		end

		--main token emitting loop
		while true do
			--get leading whitespace. The leading whitespace will include any comments 
			--preceding the token. This prevents the parser needing to deal with comments 
			--separately.
			local leadingWhite = ''
			while true do
				local c = peek()
				if WhiteChars[c] then
					--whitespace
					leadingWhite = leadingWhite..get()
				elseif c == '-' and peek(1) == '-' then
					--comment
					get();get()
					leadingWhite = leadingWhite..'--'
					local _, wholeText = tryGetLongString()
					if wholeText then
						leadingWhite = leadingWhite..wholeText
					else
						while peek() ~= '\n' and peek() ~= '' do
							leadingWhite = leadingWhite..get()
						end
					end
				else
					break
				end
			end

			--get the initial char
			local thisLine = line
			local thisChar = char
			local errorAt = ":"..line..":"..char..":> "
			local c = peek()

			--symbol to emit
			local toEmit = nil

			--branch on type
			if c == '' then
				--eof
				toEmit = {Type = 'Eof'}

			elseif UpperChars[c] or LowerChars[c] or c == '_' then
				--ident or keyword
				local start = p
				repeat
					get()
					c = peek()
				until not (UpperChars[c] or LowerChars[c] or Digits[c] or c == '_')
				local dat = src:sub(start, p-1)
				if Keywords[dat] then
					toEmit = {Type = 'Keyword', Data = dat}
				else
					toEmit = {Type = 'Ident', Data = dat}
				end

			elseif Digits[c] or (peek() == '.' and Digits[peek(1)]) then 
				--number const
				local start = p
				if c == '0' and peek(1) == 'x' then
					get();get()
					while HexDigits[peek()] do get() end
					if consume('Pp') then
						consume('+-')
						while Digits[peek()] do get() end
					end
				else
					while Digits[peek()] do get() end
					if consume('.') then
						while Digits[peek()] do get() end
					end
					if consume('Ee') then
						consume('+-')
						while Digits[peek()] do get() end
					end
				end
				toEmit = {Type = 'Number', Data = src:sub(start, p-1)}

			elseif c == '\'' or c == '\"' then
				local start = p
				--string const
				local delim = get()
				local contentStart = p
				while true do
					local c = get()
					if c == '\\' then
						get() --get the escape char
					elseif c == delim then
						break
					elseif c == '' then
						generateError("Unfinished string near <eof>")
					end
				end
				local content = src:sub(contentStart, p-2)
				local constant = src:sub(start, p-1)
				toEmit = {Type = 'String', Data = constant, Constant = content}

			elseif c == '[' then
				local content, wholetext = tryGetLongString()
				if wholetext then
					toEmit = {Type = 'String', Data = wholetext, Constant = content}
				else
					get()
					toEmit = {Type = 'Symbol', Data = '['}
				end

			elseif consume('>=<') then
				if consume('=') then
					toEmit = {Type = 'Symbol', Data = c..'='}
				else
					toEmit = {Type = 'Symbol', Data = c}
				end

			elseif consume('~') then
				if consume('=') then
					toEmit = {Type = 'Symbol', Data = '~='}
				else
					generateError("Unexpected symbol `~` in source.", 2)
				end

			elseif consume('.') then
				if consume('.') then
					if consume('.') then
						toEmit = {Type = 'Symbol', Data = '...'}
					else
						toEmit = {Type = 'Symbol', Data = '..'}
					end
				else
					toEmit = {Type = 'Symbol', Data = '.'}
				end

			elseif consume(':') then
				if consume(':') then
					toEmit = {Type = 'Symbol', Data = '::'}
				else
					toEmit = {Type = 'Symbol', Data = ':'}
				end

			elseif Symbols[c] then
				get()
				toEmit = {Type = 'Symbol', Data = c}

			else
				local contents, all = tryGetLongString()
				if contents then
					toEmit = {Type = 'String', Data = all, Constant = contents}
				else
					generateError("Unexpected Symbol `"..c.."` in source.", 2)
				end
			end

			--add the emitted symbol, after adding some common data
			toEmit.LeadingWhite = leadingWhite
			toEmit.Line = thisLine
			toEmit.Char = thisChar
			toEmit.Print = function()
				return "<"..(toEmit.Type..string.rep(' ', 7-#toEmit.Type)).."	"..(toEmit.Data or '').." >"
			end
			tokens[#tokens+1] = toEmit

			--halt after eof has been emitted
			if toEmit.Type == 'Eof' then break end
		end
	end)
	if not st then
		return false, err
	end

	--public interface:
	local tok = {}
	local savedP = {}
	local p = 1

	--getters
	function tok:Peek(n)
		n = n or 0
		return tokens[math.min(#tokens, p+n)]
	end
	function tok:Get()
		local t = tokens[p]
		p = math.min(p + 1, #tokens)
		return t
	end
	function tok:Is(t)
		return tok:Peek().Type == t
	end

	--save / restore points in the stream
	function tok:Save()
		savedP[#savedP+1] = p
	end
	function tok:Commit()
		savedP[#savedP] = nil
	end
	function tok:Restore()
		p = savedP[#savedP]
		savedP[#savedP] = nil
	end

	--either return a symbol if there is one, or return true if the requested
	--symbol was gotten.
	function tok:ConsumeSymbol(symb)
		local t = self:Peek()
		if t.Type == 'Symbol' then
			if symb then
				if t.Data == symb then
					self:Get()
					return true
				else
					return nil
				end
			else
				self:Get()
				return t
			end
		else
			return nil
		end
	end

	function tok:ConsumeKeyword(kw)
		local t = self:Peek()
		if t.Type == 'Keyword' and t.Data == kw then
			self:Get()
			return true
		else
			return nil
		end
	end

	function tok:IsKeyword(kw)
		local t = tok:Peek()
		return t.Type == 'Keyword' and t.Data == kw
	end

	function tok:IsSymbol(s)
		local t = tok:Peek()
		return t.Type == 'Symbol' and t.Data == s
	end

	function tok:IsEof()
		return tok:Peek().Type == 'Eof'
	end

	return true, tok
end


function ParseLua(src)
	local st, tok = LexLua(src)
	if not st then
		return false, tok
	end
	--
	local function GenerateError(msg)
		local err = ">> :"..tok:Peek().Line..":"..tok:Peek().Char..": "..msg.."\n"
		--find the line
		local lineNum = 0
		for line in src:gmatch("[^\n]*\n?") do
			if line:sub(-1,-1) == '\n' then line = line:sub(1,-2) end
			lineNum = lineNum+1
			if lineNum == tok:Peek().Line then
				err = err..">> `"..line:gsub('\t','		').."`\n"
				for i = 1, tok:Peek().Char do
					local c = line:sub(i,i)
					if c == '\t' then 
						err = err..'		'
					else
						err = err..' '
					end
				end
				err = err.."	 ^---"
				break
			end
		end
		return err
	end
	--
	local VarUid = 0
	local GlobalVarGetMap = {}
	local VarDigits = {
		'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 
		'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 
		's', 't', 'u', 'v', 'w', 'x', 'y', 'z',
		'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 
		'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 
		'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'
	}
	local function CreateScope(parent)
		local scope = {}
		scope.Parent = parent
		scope.LocalList = {}
		scope.LocalMap = {}
		function scope:RenameVars()
			for _, var in pairs(scope.LocalList) do
				local id;
				VarUid = 0
				repeat
					VarUid = VarUid + 1
					local varToUse = VarUid
					id = ''
					while varToUse > 0 do
						local d = varToUse % #VarDigits
						varToUse = (varToUse - d) / #VarDigits
						id = id..VarDigits[d+1]
					end
				until not GlobalVarGetMap[id] and not parent:GetLocal(id) and not scope.LocalMap[id] and not Keywords[id]
				var.Name = id
				scope.LocalMap[id] = var
			end
		end
		function scope:GetLocal(name)
			--first, try to get my variable 
			local my = scope.LocalMap[name]
			if my then return my end

			--next, try parent
			if scope.Parent then
				local par = scope.Parent:GetLocal(name)
				if par then return par end
			end

			return nil
		end
		function scope:CreateLocal(name)
			--create my own var
			local my = {}
			my.Scope = scope
			my.Name = name
			my.CanRename = true
			--
			scope.LocalList[#scope.LocalList+1] = my
			scope.LocalMap[name] = my
			--
			return my
		end
		local r = math.random(1e6,1e7-1)
		scope.Print = function() return "<Scope " .. r .. ">" end
		return scope
	end

	local ParseExpr;
	local ParseStatementList;

	local function ParseFunctionArgsAndBody(scope)
		local funcScope = CreateScope(scope)
		if not tok:ConsumeSymbol('(') then
			return false, GenerateError("`(` expected.")
		end

		--arg list
		local argList = {}
		local isVarArg = false
		while not tok:ConsumeSymbol(')') do
			if tok:Is('Ident') then
				local arg = funcScope:CreateLocal(tok:Get().Data)
				argList[#argList+1] = arg
				if not tok:ConsumeSymbol(',') then
					if tok:ConsumeSymbol(')') then
						break
					else
						return false, GenerateError("`)` expected.")
					end
				end
			elseif tok:ConsumeSymbol('...') then
				isVarArg = true
				if not tok:ConsumeSymbol(')') then
					return false, GenerateError("`...` must be the last argument of a function.")
				end
				break
			else
				return false, GenerateError("Argument name or `...` expected")
			end
		end

		--body
		local st, body = ParseStatementList(funcScope)
		if not st then return false, body end

		--end
		if not tok:ConsumeKeyword('end') then
			return false, GenerateError("`end` expected after function body")
		end

		local nodeFunc = {}
		nodeFunc.AstType = 'Function'
		nodeFunc.Scope = funcScope
		nodeFunc.Arguments = argList
		nodeFunc.Body = body
		nodeFunc.VarArg = isVarArg
		--
		return true, nodeFunc
	end


	local function ParsePrimaryExpr(scope)
		if tok:ConsumeSymbol('(') then
			local st, ex = ParseExpr(scope)
			if not st then return false, ex end
			if not tok:ConsumeSymbol(')') then
				return false, GenerateError("`)` Expected.")
			end
			--save the information about parenthesized expressions somewhere
			ex.ParenCount = (ex.ParenCount or 0) + 1
			return true, ex

		elseif tok:Is('Ident') then
			local id = tok:Get()
			local var = scope:GetLocal(id.Data)
			if not var then
				GlobalVarGetMap[id.Data] = true
			end
			--
			local nodePrimExp = {}
			nodePrimExp.AstType = 'VarExpr'
			nodePrimExp.Name = id.Data
			nodePrimExp.Local = var
			--
			return true, nodePrimExp
		else
			return false, GenerateError("primary expression expected")
		end
	end


	local function ParseSuffixedExpr(scope, onlyDotColon)
		--base primary expression
		local st, prim = ParsePrimaryExpr(scope)
		if not st then return false, prim end
		--
		while true do
			if tok:IsSymbol('.') or tok:IsSymbol(':') then
				local symb = tok:Get().Data
				if not tok:Is('Ident') then
					return false, GenerateError("<Ident> expected.")
				end
				local id = tok:Get()
				local nodeIndex = {}
				nodeIndex.AstType = 'MemberExpr'
				nodeIndex.Base = prim
				nodeIndex.Indexer = symb
				nodeIndex.Ident = id
				--
				prim = nodeIndex

			elseif not onlyDotColon and tok:ConsumeSymbol('[') then
				local st, ex = ParseExpr(scope)
				if not st then return false, ex end
				if not tok:ConsumeSymbol(']') then
					return false, GenerateError("`]` expected.")
				end
				local nodeIndex = {}
				nodeIndex.AstType = 'IndexExpr'
				nodeIndex.Base = prim
				nodeIndex.Index = ex
				--
				prim = nodeIndex

			elseif not onlyDotColon and tok:ConsumeSymbol('(') then
				local args = {}
				while not tok:ConsumeSymbol(')') do
					local st, ex = ParseExpr(scope)
					if not st then return false, ex end
					args[#args+1] = ex
					if not tok:ConsumeSymbol(',') then
						if tok:ConsumeSymbol(')') then
							break
						else
							return false, GenerateError("`)` Expected.")
						end
					end
				end
				local nodeCall = {}
				nodeCall.AstType = 'CallExpr'
				nodeCall.Base = prim
				nodeCall.Arguments = args
				--
				prim = nodeCall

			elseif not onlyDotColon and tok:Is('String') then
				--string call
				local nodeCall = {}
				nodeCall.AstType = 'StringCallExpr'
				nodeCall.Base = prim
				nodeCall.Arguments	= {tok:Get()}
				--
				prim = nodeCall

			elseif not onlyDotColon and tok:IsSymbol('{') then
				--table call
				local st, ex = ParseExpr(scope)
				if not st then return false, ex end
				local nodeCall = {}
				nodeCall.AstType = 'TableCallExpr'
				nodeCall.Base = prim
				nodeCall.Arguments = {ex}
				--
				prim = nodeCall

			else
				break
			end
		end
		return true, prim
	end


	local function ParseSimpleExpr(scope)
		if tok:Is('Number') then
			local nodeNum = {}
			nodeNum.AstType = 'NumberExpr'
			nodeNum.Value = tok:Get()
			return true, nodeNum

		elseif tok:Is('String') then
			local nodeStr = {}
			nodeStr.AstType = 'StringExpr'
			nodeStr.Value = tok:Get()
			return true, nodeStr

		elseif tok:ConsumeKeyword('nil') then
			local nodeNil = {}
			nodeNil.AstType = 'NilExpr'
			return true, nodeNil

		elseif tok:IsKeyword('false') or tok:IsKeyword('true') then
			local nodeBoolean = {}
			nodeBoolean.AstType = 'BooleanExpr'
			nodeBoolean.Value = (tok:Get().Data == 'true')
			return true, nodeBoolean

		elseif tok:ConsumeSymbol('...') then
			local nodeDots = {}
			nodeDots.AstType = 'DotsExpr'
			return true, nodeDots

		elseif tok:ConsumeSymbol('{') then
			local v = {}
			v.AstType = 'ConstructorExpr'
			v.EntryList = {}
			--
			while true do
				if tok:IsSymbol('[') then
					--key
					tok:Get()
					local st, key = ParseExpr(scope)
					if not st then 
						return false, GenerateError("Key Expression Expected")
					end
					if not tok:ConsumeSymbol(']') then
						return false, GenerateError("`]` Expected")
					end
					if not tok:ConsumeSymbol('=') then
						return false, GenerateError("`=` Expected")
					end
					local st, value = ParseExpr(scope)
					if not st then
						return false, GenerateError("Value Expression Expected")
					end
					v.EntryList[#v.EntryList+1] = {
						Type = 'Key';
						Key = key;
						Value = value;
					}

				elseif tok:Is('Ident') then
					--value or key
					local lookahead = tok:Peek(1)
					if lookahead.Type == 'Symbol' and lookahead.Data == '=' then
						--we are a key
						local key = tok:Get() 
						if not tok:ConsumeSymbol('=') then
							return false, GenerateError("`=` Expected")
						end
						local st, value = ParseExpr(scope)
						if not st then
							return false, GenerateError("Value Expression Expected")
						end
						v.EntryList[#v.EntryList+1] = {
							Type = 'KeyString';
							Key = key.Data;
							Value = value; 
						}

					else
						--we are a value
						local st, value = ParseExpr(scope)
						if not st then
							return false, GenerateError("Value Exected")
						end
						v.EntryList[#v.EntryList+1] = {
							Type = 'Value';
							Value = value;
						}

					end
				elseif tok:ConsumeSymbol('}') then
					break

				else
					--value
					local st, value = ParseExpr(scope)
					v.EntryList[#v.EntryList+1] = {
						Type = 'Value';
						Value = value;
					}
					if not st then
						return false, GenerateError("Value Expected")
					end
				end

				if tok:ConsumeSymbol(';') or tok:ConsumeSymbol(',') then
					--all is good
				elseif tok:ConsumeSymbol('}') then
					break
				else
					return false, GenerateError("`}` or table entry Expected")
				end
			end
			return true, v

		elseif tok:ConsumeKeyword('function') then
			local st, func = ParseFunctionArgsAndBody(scope)
			if not st then return false, func end
			--
			func.IsLocal = true
			return true, func

		else
			return ParseSuffixedExpr(scope)
		end
	end


	local unops = lookupify{'-', 'not', '#'}
	local unopprio = 8
	local priority = {
		['+'] = {6,6};
		['-'] = {6,6};
		['%'] = {7,7};
		['/'] = {7,7};
		['*'] = {7,7};
		['^'] = {10,9};
		['..'] = {5,4};
		['=='] = {3,3};
		['<'] = {3,3};
		['<='] = {3,3};
		['~='] = {3,3};
		['>'] = {3,3};
		['>='] = {3,3};
		['and'] = {2,2};
		['or'] = {1,1};
	}
	local function ParseSubExpr(scope, level)
		--base item, possibly with unop prefix
		local st, exp
		if unops[tok:Peek().Data] then
			local op = tok:Get().Data
			st, exp = ParseSubExpr(scope, unopprio)
			if not st then return false, exp end
			local nodeEx = {}
			nodeEx.AstType = 'UnopExpr'
			nodeEx.Rhs = exp
			nodeEx.Op = op
			exp = nodeEx
		else
			st, exp = ParseSimpleExpr(scope)
			if not st then return false, exp end
		end

		--next items in chain
		while true do
			local prio = priority[tok:Peek().Data]
			if prio and prio[1] > level then
				local op = tok:Get().Data
				local st, rhs = ParseSubExpr(scope, prio[2])
				if not st then return false, rhs end
				local nodeEx = {}
				nodeEx.AstType = 'BinopExpr'
				nodeEx.Lhs = exp
				nodeEx.Op = op
				nodeEx.Rhs = rhs
				--
				exp = nodeEx
			else
				break
			end
		end

		return true, exp
	end


	ParseExpr = function(scope)
		return ParseSubExpr(scope, 0)
	end


	local function ParseStatement(scope)
		local stat = nil
		if tok:ConsumeKeyword('if') then
			--setup
			local nodeIfStat = {}
			nodeIfStat.AstType = 'IfStatement'
			nodeIfStat.Clauses = {}

			--clauses
			repeat
				local st, nodeCond = ParseExpr(scope)
				if not st then return false, nodeCond end
				if not tok:ConsumeKeyword('then') then
					return false, GenerateError("`then` expected.")
				end
				local st, nodeBody = ParseStatementList(scope)
				if not st then return false, nodeBody end
				nodeIfStat.Clauses[#nodeIfStat.Clauses+1] = {
					Condition = nodeCond;
					Body = nodeBody;
				}
			until not tok:ConsumeKeyword('elseif')

			--else clause
			if tok:ConsumeKeyword('else') then
				local st, nodeBody = ParseStatementList(scope)
				if not st then return false, nodeBody end
				nodeIfStat.Clauses[#nodeIfStat.Clauses+1] = {
					Body = nodeBody;
				}
			end

			--end
			if not tok:ConsumeKeyword('end') then
				return false, GenerateError("`end` expected.")
			end

			stat = nodeIfStat

		elseif tok:ConsumeKeyword('while') then
			--setup
			local nodeWhileStat = {}
			nodeWhileStat.AstType = 'WhileStatement'

			--condition
			local st, nodeCond = ParseExpr(scope)
			if not st then return false, nodeCond end

			--do
			if not tok:ConsumeKeyword('do') then
				return false, GenerateError("`do` expected.")
			end

			--body
			local st, nodeBody = ParseStatementList(scope)
			if not st then return false, nodeBody end

			--end
			if not tok:ConsumeKeyword('end') then
				return false, GenerateError("`end` expected.")
			end

			--return
			nodeWhileStat.Condition = nodeCond
			nodeWhileStat.Body = nodeBody
			stat = nodeWhileStat

		elseif tok:ConsumeKeyword('do') then
			--do block
			local st, nodeBlock = ParseStatementList(scope)
			if not st then return false, nodeBlock end
			if not tok:ConsumeKeyword('end') then
				return false, GenerateError("`end` expected.")
			end

			local nodeDoStat = {}
			nodeDoStat.AstType = 'DoStatement'
			nodeDoStat.Body = nodeBlock
			stat = nodeDoStat

		elseif tok:ConsumeKeyword('for') then
			--for block
			if not tok:Is('Ident') then
				return false, GenerateError("<ident> expected.")
			end
			local baseVarName = tok:Get()
			if tok:ConsumeSymbol('=') then
				--numeric for
				local forScope = CreateScope(scope)
				local forVar = forScope:CreateLocal(baseVarName.Data)
				--
				local st, startEx = ParseExpr(scope)
				if not st then return false, startEx end
				if not tok:ConsumeSymbol(',') then
					return false, GenerateError("`,` Expected")
				end
				local st, endEx = ParseExpr(scope)
				if not st then return false, endEx end
				local st, stepEx;
				if tok:ConsumeSymbol(',') then
					st, stepEx = ParseExpr(scope)
					if not st then return false, stepEx end
				end
				if not tok:ConsumeKeyword('do') then
					return false, GenerateError("`do` expected")
				end
				--
				local st, body = ParseStatementList(forScope)
				if not st then return false, body end
				if not tok:ConsumeKeyword('end') then
					return false, GenerateError("`end` expected")
				end
				--
				local nodeFor = {}
				nodeFor.AstType = 'NumericForStatement'
				nodeFor.Scope = forScope
				nodeFor.Variable = forVar
				nodeFor.Start = startEx
				nodeFor.End = endEx
				nodeFor.Step = stepEx
				nodeFor.Body = body
				stat = nodeFor
			else
				--generic for
				local forScope = CreateScope(scope)
				--
				local varList = {forScope:CreateLocal(baseVarName.Data)}
				while tok:ConsumeSymbol(',') do
					if not tok:Is('Ident') then
						return false, GenerateError("for variable expected.")
					end
					varList[#varList+1] = forScope:CreateLocal(tok:Get().Data)
				end
				if not tok:ConsumeKeyword('in') then
					return false, GenerateError("`in` expected.")
				end
				local generators = {}
				local st, firstGenerator = ParseExpr(scope)
				if not st then return false, firstGenerator end
				generators[#generators+1] = firstGenerator
				while tok:ConsumeSymbol(',') do
					local st, gen = ParseExpr(scope)
					if not st then return false, gen end
					generators[#generators+1] = gen
				end
				if not tok:ConsumeKeyword('do') then
					return false, GenerateError("`do` expected.")
				end
				local st, body = ParseStatementList(forScope)
				if not st then return false, body end
				if not tok:ConsumeKeyword('end') then
					return false, GenerateError("`end` expected.")
				end
				--
				local nodeFor = {}
				nodeFor.AstType = 'GenericForStatement'
				nodeFor.Scope = forScope
				nodeFor.VariableList = varList
				nodeFor.Generators = generators
				nodeFor.Body = body
				stat = nodeFor
			end

		elseif tok:ConsumeKeyword('repeat') then
			local st, body = ParseStatementList(scope)
			if not st then return false, body end
			--
			if not tok:ConsumeKeyword('until') then
				return false, GenerateError("`until` expected.")
			end
			--
			local st, cond = ParseExpr(scope)
			if not st then return false, cond end
			--
			local nodeRepeat = {}
			nodeRepeat.AstType = 'RepeatStatement'
			nodeRepeat.Condition = cond
			nodeRepeat.Body = body
			stat = nodeRepeat

		elseif tok:ConsumeKeyword('function') then
			if not tok:Is('Ident') then
				return false, GenerateError("Function name expected")
			end
			local st, name = ParseSuffixedExpr(scope, true) --true => only dots and colons
			if not st then return false, name end
			--
			local st, func = ParseFunctionArgsAndBody(scope)
			if not st then return false, func end
			--
			func.IsLocal = false
			func.Name = name
			stat = func

		elseif tok:ConsumeKeyword('local') then
			if tok:Is('Ident') then
				local varList = {tok:Get().Data}
				while tok:ConsumeSymbol(',') do
					if not tok:Is('Ident') then
						return false, GenerateError("local var name expected")
					end
					varList[#varList+1] = tok:Get().Data
				end

				local initList = {}
				if tok:ConsumeSymbol('=') then
					repeat
						local st, ex = ParseExpr(scope)
						if not st then return false, ex end
						initList[#initList+1] = ex
					until not tok:ConsumeSymbol(',')
				end

				--now patch var list
				--we can't do this before getting the init list, because the init list does not
				--have the locals themselves in scope.
				for i, v in pairs(varList) do
					varList[i] = scope:CreateLocal(v)
				end

				local nodeLocal = {}
				nodeLocal.AstType = 'LocalStatement'
				nodeLocal.LocalList = varList
				nodeLocal.InitList = initList
				--
				stat = nodeLocal

			elseif tok:ConsumeKeyword('function') then
				if not tok:Is('Ident') then
					return false, GenerateError("Function name expected")
				end
				local name = tok:Get().Data		
				local localVar = scope:CreateLocal(name)
				--	
				local st, func = ParseFunctionArgsAndBody(scope)
				if not st then return false, func end
				--
				func.Name = localVar
				func.IsLocal = true
				stat = func

			else
				return false, GenerateError("local var or function def expected")
			end

		elseif tok:ConsumeKeyword('return') then
			local exList = {}
			if not tok:IsKeyword('end') then
				local st, firstEx = ParseExpr(scope)
				if st then 
					exList[1] = firstEx
					while tok:ConsumeSymbol(',') do
						local st, ex = ParseExpr(scope)
						if not st then return false, ex end
						exList[#exList+1] = ex
					end
				end
			end

			local nodeReturn = {}
			nodeReturn.AstType = 'ReturnStatement'
			nodeReturn.Arguments = exList
			stat = nodeReturn

		elseif tok:ConsumeKeyword('break') then
			local nodeBreak = {}
			nodeBreak.AstType = 'BreakStatement'
			stat = nodeBreak

		elseif tok:ConsumeKeyword('continue') then
			local nodeBreak = {}
			nodeBreak.AstType = 'ContinueStatement'
			stat = nodeBreak

		else
			--statementParseExpr
			local st, suffixed = ParseSuffixedExpr(scope)
			if not st then return false, suffixed end

			--assignment or call?
			if tok:IsSymbol(',') or tok:IsSymbol('=') then
				--check that it was not parenthesized, making it not an lvalue
				if (suffixed.ParenCount or 0) > 0 then
					return false, GenerateError("Can not assign to parenthesized expression, is not an lvalue")
				end

				--more processing needed
				local lhs = {suffixed}
				while tok:ConsumeSymbol(',') do
					local st, lhsPart = ParseSuffixedExpr(scope)
					if not st then return false, lhsPart end
					lhs[#lhs+1] = lhsPart
				end

				--equals
				if not tok:ConsumeSymbol('=') then
					return false, GenerateError("`=` Expected.")
				end

				--rhs
				local rhs = {}
				local st, firstRhs = ParseExpr(scope)
				if not st then return false, firstRhs end
				rhs[1] = firstRhs
				while tok:ConsumeSymbol(',') do
					local st, rhsPart = ParseExpr(scope)
					if not st then return false, rhsPart end
					rhs[#rhs+1] = rhsPart
				end

				--done
				local nodeAssign = {}
				nodeAssign.AstType = 'AssignmentStatement'
				nodeAssign.Lhs = lhs
				nodeAssign.Rhs = rhs
				stat = nodeAssign

			elseif suffixed.AstType == 'CallExpr' or 
				suffixed.AstType == 'TableCallExpr' or 
				suffixed.AstType == 'StringCallExpr' 
			then
				--it's a call statement
				local nodeCall = {}
				nodeCall.AstType = 'CallStatement'
				nodeCall.Expression = suffixed
				stat = nodeCall
			else
				return false, GenerateError("Assignment Statement Expected")
			end
		end

		stat.HasSemicolon = tok:ConsumeSymbol(';')
		return true, stat
	end


	local statListCloseKeywords = lookupify{'end', 'else', 'elseif', 'until'}
	ParseStatementList = function(scope)
		local nodeStatlist = {}
		nodeStatlist.Scope = CreateScope(scope)
		nodeStatlist.AstType = 'Statlist'
		--
		local stats = {}
		--
		while not statListCloseKeywords[tok:Peek().Data] and not tok:IsEof() do
			local st, nodeStatement = ParseStatement(nodeStatlist.Scope)
			if not st then return false, nodeStatement end
			stats[#stats+1] = nodeStatement
		end
		--
		nodeStatlist.Body = stats
		return true, nodeStatlist
	end


	local function mainfunc()
		local topScope = CreateScope()
		return ParseStatementList(topScope)
	end

	local st, main = mainfunc()
	--print("Last Token: "..PrintTable(tok:Peek()))
	return st, main
end

local bitmanager = (function()
	local function padleft(s,n,p)
		return string.rep(p,n-#s)..s
	end
	local function padright(s,n,p)
		return s..string.rep(p,n-#s)
	end
	local function ToNum(b) --Easy shorthand
		return tonumber(b,2)
	end
	local function ToBit(n,pad)
		assert(math.floor(n) == n,"Can't convert a non-int to regular bit format")
		if n == 0 then
			if pad then
				return padleft("0",pad,"0")
			else
				return "0"
			end
		end
		local pow = math.floor(math.log(n,2))
		local final = ""
		while true do
			if n >= 2^pow then
				n = n - 2^pow
				final = final .. "1"
			else
				final = final .. "0"
			end
			pow = pow - 1
			if pow < 0 then
				if pad then
					return padleft(final,pad,"0")
				else
					return final
				end
			end
		end
	end
	local function DecToBit(d,pad)
		assert(math.abs(d) < 1,"Can't convert non-zero integral decimal to decimal bit")
		assert(type(pad)=="number","DecToBit requires a valid pad length")
		local result = ""
		local iterations = 0
		while true do
			local NextNum = d * 2
			if NextNum > 1 then
				result = result .. "1"
			elseif NextNum == 1 then
				return padright(result .. "1",pad,"0")
			else
				result = result .. "0"
			end
			d = NextNum - math.floor(NextNum)
			iterations = iterations + 1
			if iterations >= pad then
				return result
			end
		end
	end
	local function NormalizeScientific(bits)
		local raw = string.gsub(bits,"%.","")
		local NotationOffset = string.find(raw,"1")
		local Normalized = string.sub(raw,NotationOffset,NotationOffset).."."..string.sub(raw,NotationOffset+1)
		local Exponent = string.find(bits,"%.")-2-(NotationOffset-1)
		return Normalized,Exponent
	end

	local BaseBitWriter = {Data=""}
	function BaseBitWriter:Write(digit,strictWidth)
		local BitRepresentation = ToBit(digit,strictWidth)
		if strictWidth then
			assert(#BitRepresentation <= strictWidth,"Digit width passed provided limit of "..strictWidth)
		end
		self.Data = self.Data .. BitRepresentation
	end
	function BaseBitWriter:WriteString(str)
		for _,Character in next,{string.byte(str,1,-1)} do
			self.Data = self.Data .. ToBit(Character,8)
		end
	end

	function BaseBitWriter:WriteDouble(double)
		if double == 0 then
			self.Data = self.Data .. string.rep("0",64)
			return
		end
		local sign = (double < 0 and "1") or "0"
		double = math.abs(double)
		local integral,fractional = math.modf(double)
		local RequiredBuffer = 0
		if fractional ~= 0 then
			RequiredBuffer = math.max(math.floor(math.log(1/fractional,2)),0)
		end
		--Buffer is required should the default 53 bits not be enough data due to a large shift when normalizing the scientific.
		--AKA: If 1 does not appear as early as 0.1[...] then normalization fails due to lack of data - that bad, so generate more
		local IntegralBits,FractionalBits = ToBit(integral),DecToBit(fractional,53+RequiredBuffer)
		local NormalizedBits,Exponent = NormalizeScientific(IntegralBits.."."..FractionalBits)
		NormalizedBits = string.sub(NormalizedBits,3,54)
		if #NormalizedBits~=52 then
			warn("[bitmanager] Precision lost during handling of double, missing",52-#NormalizedBits,"bits\nFractional:",fractional)
			NormalizedBits = padright(NormalizedBits,52,"0")
		end
		Exponent = ToBit(Exponent+1023,11)
		self.Data = self.Data .. sign .. Exponent .. NormalizedBits
	end
	function BaseBitWriter:ToString()
		local final = ""
		local Data = self.Data
		while true do
			local NextByte = "01" .. string.sub(Data,1,6)
			if #NextByte < 8 then
				final = final .. string.char(ToNum(padright(NextByte,8,"0")))
				break
			else
				final = final .. string.char(ToNum(NextByte))
				Data = string.sub(Data,7,-1)
			end
		end
		return final
	end

	local function L1Copy(t,b)
		local b = b or {}
		for x,y in next,t do
			b[x] = y
		end
		return b
	end
	local function NewBitWriter(PresetData)
		local BitWriter = L1Copy(BaseBitWriter,{Data=PresetData or ""})
		return BitWriter
	end

	return NewBitWriter
end)()

local serializer = (function()
	local bitmanager = bitmanager

	local TYPE_TABLE_START=0
	local TYPE_TABLE_END=1
	local TYPE_STRING=2
	local TYPE_NUMBER=3
	local TYPE_BOOLEAN=4
	local TYPE_NUMBER_BASIC=5
	local TYPE_NUMBER_SUPERBASIC=6
	local TYPE_NUMBER_SIMPLE=7

	local TYPE_WIDTH=3

	local function Serialize(t,raw)
		local Output = bitmanager()
		Output:Write(TYPE_TABLE_START,TYPE_WIDTH)
		local function HandleType(obj)
			if type(obj) == "table" then
				Output.Data = Output.Data .. Serialize(obj,true)
			elseif type(obj) == "string" then
				Output:Write(TYPE_STRING,TYPE_WIDTH)
				obj = string.gsub(obj,"\\","\\\\")
				obj = string.gsub(obj,"\0","\\0") --Escape non-terminators
				Output:WriteString(obj)
				Output:Write(0,8) --Null terminator
			elseif type(obj) == "number" then
				if obj == math.floor(obj) and obj < 8 and obj >= 0 then
					Output:Write(TYPE_NUMBER_SUPERBASIC,TYPE_WIDTH)
					Output:Write(obj,3)
				elseif obj == math.floor(obj) and obj < 16 and obj >= 0 then
					Output:Write(TYPE_NUMBER_BASIC,TYPE_WIDTH)
					Output:Write(obj,4)
				elseif obj == math.floor(obj) and obj < 32 and obj >= 0 then
					Output:Write(TYPE_NUMBER_SIMPLE,TYPE_WIDTH)
					Output:Write(obj,5)
				else
					Output:Write(TYPE_NUMBER,TYPE_WIDTH)
					Output:WriteDouble(obj)
				end
			elseif type(obj) == "boolean" then
				Output:Write(TYPE_BOOLEAN,TYPE_WIDTH)
				Output:Write((obj==true and 1) or 0) --Simple enough
			elseif type(obj) == "function" then
				--Do absolutely nothing
			else
				error("Object of type "..type(obj).." can't be processed by the serializer")
			end
		end
		for a,b in next,t do
			HandleType(a)
			HandleType(b)
		end
		Output:Write(TYPE_TABLE_END,TYPE_WIDTH)
		if raw then
			return Output.Data
		else
			return Output:ToString()
		end
	end

	return Serialize
end)()

local ExpressionSet = {
	--[["Function", ]]"VarExpr", "MemberExpr", "IndexExpr", "CallExpr", "StringCallExpr",
	"TableCallExpr", "NumberExpr", "StringExpr", "NilExpr", "BooleanExpr",
	"DotsExpr", "ConstructorExpr", "UnopExpr", "BinopExpr",
}
local StatementSet = {
	--[["Function", ]]"IfStatement", "WhileStatement", "DoStatement", "NumericForStatement",
	"GenericForStatement", "RepeatStatement", "LocalStatement", "ReturnStatement",
	"BreakStatement", "ContinueStatement", "AssignmentStatement", "CallStatement",
}

local AstTypeToID = {
	Statlist=nil, Function=1,

	--[[Function=1, ]]VarExpr=2, MemberExpr=3, IndexExpr=4, CallExpr=5, StringCallExpr=6,
	TableCallExpr=7, NumberExpr=8, StringExpr=9, NilExpr=10, BooleanExpr=11,
	DotsExpr=12, ConstructorExpr=13, UnopExpr=14, BinopExpr=15,

	--[[Function=1, ]]IfStatement=2, WhileStatement=3, DoStatement=4, NumericForStatement=5,
	GenericForStatement=6, RepeatStatement=7, LocalStatement=8, ReturnStatement=9,
	BreakStatement=10, ContinueStatement=11, AssignmentStatement=12, CallStatement=13,
}
--We can actually duplicate the IDs for statements vs expressions
--Since we always know when one leads to the other, meaning theres no concern there
--We don't even need an ID for a Statlist, so lets just nil it!

local BinOpToID = {
	["+"]=1, ["-"]=2, ["%"]=3, ["/"]=4, ["*"]=5, ["^"]=6, [".."]=7, ["=="]=8,
	["<"]=9, ["<="]=10, ["~="]=11, [">"]=12, [">="]=13, ["and"]=14, ["or"]=15
}
local UnOpToID = {
	["-"]=1, ["not"]=2, ["#"]=3
}

return function(C)
	local s,p = ParseLua(C)
	if not s then
		warn("Failed to parse the lua -",p)
		return false,p
	end

	local checked = {}
	local function AssignKey(t,k,n)
		if t[k] ~= nil then
			t[n] = t[k]
			t[k] = nil
		end
	end
	local function deepModify(t)
		--Remove irrelevant
		t.Scope = nil
		t.Char = nil
		t.Position = nil
		t.Line = nil
		t.CanRename = nil
		t.Print = nil
		t.LeadingWhite = nil

		--Simplify values
		local HasAstType = type(t.AstType) == "string"
		if t.Local then
			t.Local = true
		end
		if t.Op then
			if t.AstType == "BinopExpr" then
				t.Op = BinOpToID[t.Op]
			elseif t.AstType == "UnopExpr" then
				t.Op = UnOpToID[t.Op]
			end
		end
		if t.Indexer then
			t[6] = (t.Indexer == ":" and true or false)
			t.Indexer = nil
		end
		if t.AstType then
			t[7] = AstTypeToID[t.AstType] or math.random(1,31) --If it doesnt matter, just have fun
			t.AstType = nil
		end
		if t.Type then
			local v = t.Type
			t.Type = nil
			if v == "Key" then
				t[27] = 0
			elseif v == "KeyString" then
				t[27] = 1
			elseif v == "Value" then
				t[27] = 2
			end
		end

		--Obscure naming
		AssignKey(t,"Name",0)
		AssignKey(t,"Body",1)
		AssignKey(t,"Index",2)
		AssignKey(t,"Arguments",3)
		AssignKey(t,"Ident",4)
		AssignKey(t,"Base",5)
		--6 = Indexer
		--7 = AstType
		AssignKey(t,"Lhs",8)
		AssignKey(t,"Rhs",9)
		AssignKey(t,"Condition",10)
		AssignKey(t,"Clauses",11)
		AssignKey(t,"Op",12)
		AssignKey(t,"EntryList",13)
		AssignKey(t,"VarArg",14)
		AssignKey(t,"InitList",15)
		AssignKey(t,"Value",16)
		AssignKey(t,"Local",17)
		AssignKey(t,"LocalList",18)
		AssignKey(t,"Generators",19)
		AssignKey(t,"VariableList",20)
		AssignKey(t,"Expression",21)
		AssignKey(t,"IsLocal",22)
		AssignKey(t,"Start",23)
		AssignKey(t,"End",24)
		AssignKey(t,"Step",25)
		AssignKey(t,"Variable",26)
		--27 = Type
		AssignKey(t,"Key",28)
		AssignKey(t,"Data",29)
		AssignKey(t,"Constant",30)

		--Fake data
		if math.random(1,12) == 1 and HasAstType then
			--Do not add fake data if no AstType is present, as this could screw a Pairs check
			for i = math.random(0,4),31 do
				if t[i] == nil then
					t[i] = false
					break
				end
			end
		end

		--Check subtables
		for a,b in next,t do
			if type(b) == "table" and not checked[b] then
				checked[b] = true
				deepModify(b)
			end
		end
	end
	deepModify(p)

	return true,serializer(p)
end]]></ProtectedString>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="ModuleScript" referent="RBXCFE28D2F8B844E8FB872948F84FCC06B">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">ExecutorText</string>
				<string name="ScriptGuid">{DCD3C548-F4A8-48B3-8F1A-913F16D96ED2}</string>
				<ProtectedString name="Source">return [===[return(function(a)local b,c,d,e=string.sub,string.byte,string.rep,string.char;local f,g=math.floor,math.log;local h,i,j,k,l,m,n,o,p=type,pairs,select,unpack,getfenv,error,tonumber,tostring,assert;local q,r,s=true,false,nil;local t;local u;local function v(w)local x={}x.P=w;x.L={}function x:GL(y)local z=x.L[y]if z then return z end;if x.P then local A=x.P:GL(y)if A then return A end end;return s end;function x:SL(y,B)local C=x:GL(y)if not C then m(&quot;Bad SL &quot;..o(y))end;C[16]=B end;function x:ML(y,B)local z={}z.S=x;z[0]=y;z[16]=B;x.L[y]=z;return z end;return x end;local D=__ENV or l()local E={}local function F(G,...)local H=E[G]or{1,1}local I={...}local J=H[1]for K=J,H[2]do G[K]=s end;for K=1,j(&quot;#&quot;,...)do G[J]=I[K]J=J+1 end;E[G]={H[1]+1,J}end;u=function(L,x,M)if L[7]==2 then if M then return L,q else local N=x:GL(L[0])if not N then if L[17]then m(&quot;Expected &apos;&quot;..o(L[0])..&quot;&apos; was missing&quot;)end else return N[16]end;return D[L[0]]end elseif L[7]==8 then return n(L[16][29])elseif L[7]==9 then return L[16][30]elseif L[7]==11 then return L[16]elseif L[7]==10 then return s elseif L[7]==15 then local O=u(L[8],x)local P=u(L[9],x)local Q=L[12]if Q==1 then return O+P elseif Q==2 then return O-P elseif Q==3 then return O%P elseif Q==4 then return O/P elseif Q==5 then return O*P elseif Q==6 then return O^P elseif Q==7 then return O..P elseif Q==8 then return O==P elseif Q==9 then return O&lt;P elseif Q==10 then return O&lt;=P elseif Q==11 then return O~=P elseif Q==12 then return O&gt;P elseif Q==13 then return O&gt;=P elseif Q==14 then return O and P elseif Q==15 then return O or P end elseif L[7]==14 then local P=u(L[9],x)local Q=L[12]if Q==1 then return-P elseif Q==2 then return not P elseif Q==3 then return#P end elseif L[7]==12 then return k(x:GL(&quot;...&quot;)[16])elseif L[7]==5 or L[7]==7 or L[7]==6 then local R={}for S,T in i(L[3])do if L[7]==6 then R={T[30]}else F(R,u(T,x))end end;return u(L[5],x)(k(R))elseif L[7]==4 then if M then return L,q else return u(L[5],x)[u(L[2],x)]end elseif L[7]==3 then if M then return L,q else if L[6]==r then return u(L[5],x)[L[4][29]]elseif L[6]==q then local U=u(L[5],x)local V=U[L[4][29]]if h(V)==&quot;function&quot;then return function(...)return V(U,...)end else return V end end end elseif L[7]==1 then return function(...)local W=v(x)local X={...}for K=1,#L[3]do local T=L[3][K]if T then W:ML(T[0],X[K])end end;if L[14]then local Y={}for K=#L[3]+1,#X do Y[#Y+1]=X[K]end;W:ML(&quot;...&quot;,Y)end;local Z=t(L[1],W)if not Z then return elseif Z.T==1 then return k(Z.D)else local _=Z.T==2 and&quot;break&quot;or&quot;continue&quot;m(&quot;You tried to &quot;.._..&quot; when not in a loop and look at where that landed you. Go think about your actions.&quot;)end end elseif L[7]==13 then local V={}for S,a0 in i(L[13])do if a0[27]==0 then V[u(a0[28],x)]=u(a0[16],x)elseif a0[27]==1 then V[a0[28]]=u(a0[16],x)end end;for S,a0 in i(L[13])do if a0[27]==2 then F(V,u(a0[16],x))end end;return V end end;local a1=function(_)if _[7]==12 then local V={}for K=1,#_[9]do F(V,u(_[9][K],_.S))end;for K=1,#_[8]do local O,a2=u(_[8][K],_.S,q)local P=V[K]if a2 then if O[7]==2 then if O[17]then _.S:SL(O[0],P)else D[O[0]]=P end elseif O[7]==3 then local U=u(O[5],_.S)U[O[4][29]]=P elseif O[7]==4 then local U=u(O[5],_.S)U[u(O[2],_.S)]=P else m(&quot;Freaky handle &quot;..o(_[7]))end end end elseif _[7]==13 then u(_[21],_.S)elseif _[7]==8 then local V={}for K=1,#_[15]do F(V,u(_[15][K],_.S))end;for K=1,#_[18]do local C=_[18][K]_.S:ML(C[0],V[K])end elseif _[7]==2 then for S,a3 in i(_[11])do if not a3[10]or u(a3[10],_.S)then return t(a3[1],v(_.S))end end elseif _[7]==3 then while u(_[10],_.S)do local Z=t(_[1],v(_.S))if Z then if Z.T==2 then return elseif Z.T==1 then return Z end end end elseif _[7]==4 then return t(_[1],v(_.S))elseif _[7]==9 then local a4={}for S,T in i(_[3])do F(a4,u(T,_.S))end;return a4 elseif _[7]==10 then return q elseif _[7]==11 then return r elseif _[7]==7 then repeat local Z=t(_[1],v(_.S))if Z then if Z.T==2 then return elseif Z.T==1 then return Z end end until u(_[10],_.S)elseif _[7]==1 then local y=_[0]if y[7]==3 then if y[6]==r then local U=u(y[5],_.S)local a5=u(_,_.S)U[y[4][29]]=a5 elseif y[6]==q then for K=#_[3],1,-1 do _[3][K+1]=_[3][K]end;_[3][1]={[0]=&quot;self&quot;,[17]=q}local U=u(y[5],_.S)local a5=u(_,_.S,q)U[y[4][29]]=a5 end else local a5=u(_,_.S)if _[22]then _.S:ML(y[0],a5)else D[y[0]]=a5 end end elseif _[7]==6 then local a6,a7,a8;local a9=_[19]if not a9[2]then a6,a7,a8=u(a9[1],_.S)else a6=u(a9[1],_.S)a7=u(a9[2],_.S)if a9[3]then a8=u(a9[3],_.S)end end;while q do local W=v(_.S)local R={a6(a7,a8)}a8=R[1]if a8==s then break end;for K=1,#R do W:ML(_[20][K][0],R[K])end;local Z=t(_[1],W)if Z then if Z.T==2 then return elseif Z.T==1 then return Z end end end elseif _[7]==5 then local aa=n(u(_[23],_.S))local ab=n(u(_[24],_.S))local ac=_[25]and n(u(_[25],_.S))or 1;while ac&gt;0 and aa&lt;=ab or ac&lt;=0 and aa&gt;=ab do local W=v(_.S)W:ML(_[26][0],aa)local Z=t(_[1],W)if Z then if Z.T==2 then return elseif Z.T==1 then return Z end end;aa=aa+ac end else m(&quot;Had no handle for &quot;..o(_[7]))end end;t=function(ad,x)for S,ae in i(ad[1])do ae.S=x;local V=a1(ae)if h(V)==&quot;table&quot;then if not V.P then return{P=q,T=1,D=V}else return V end elseif h(V)==&quot;boolean&quot;then return{P=q,T=V==q and 2 or 3}end end end;return function()a=(function(af)local function ag(ah,ai,aj)return d(aj,ai-#ah)..ah end;local function ak(al)return n(al,2)end;local function am(ai,an)p(f(ai)==ai,&quot;Can&apos;t convert non-int&quot;)if ai==0 then return ag(&quot;0&quot;,an or 1,&quot;0&quot;)end;local ao=f(g(ai,2))local ap=&quot;&quot;while ao&gt;=0 do if ai&gt;=2^ao then ai=ai-2^ao;ap=ap..&quot;1&quot;else ap=ap..&quot;0&quot;end;ao=ao-1 end;return ag(ap,an or 1,&quot;0&quot;)end;local function aq(ar)local ao=0;local as=0;for at=1,#ar do local au=b(ar,at,at)if au==&quot;1&quot;then as=as+2^ao end;ao=ao-1 end;return as end;local av=af;local aw=&quot;&quot;local function ax(ay)for K=1,f((ay-#aw-1)/6)+1 do aw=aw..b(am(c(av,1,1),8),3,-1)av=b(av,2,-1)end end;local function az(ay)ax(ay)local aA=b(aw,1,ay)aw=b(aw,ay+1)return aA end;local function aB(ay)return ak(az(ay))end;local function aC()return e(aB(8))end;local function aD()local aE,aF,aG=aB(1),aB(11),az(52)aE,aF=aE==0 and 1 or-1,2^(aF-1023)return aE*aF*aq(&quot;1&quot;..aG)end;local aH=0;local aI=1;local aJ=2;local aK=3;local aL=4;local aM=5;local aN=6;local aO=7;local aP=3;local function aQ(aR)if not aR then p(aB(aP)==aH,&quot;Invalid SD&quot;)end;local aS={}local aT=s;local function aU(aV)if aT then aS[aT]=aV;aT=s else aT=aV end end;while q do local aW=aB(aP)if aW==aI then return aS elseif aW==aH then aU(aQ(q))elseif aW==aJ then local aX=&quot;&quot;while q do local aY=aC()if aY==&quot;\0&quot;then aU(aX)break elseif aY==&quot;\\&quot;then aX=aX..aC()else aX=aX..aY end end elseif aW==aK then aU(aD())elseif aW==aL then aU(aB(1)==1)elseif aW==aM then aU(aB(4))elseif aW==aN then aU(aB(3))elseif aW==aO then aU(aB(5))else m(&quot;Unknown Ot &quot;..o(aW)..&quot; during DS&quot;)end end end;return aQ()end)(a)local Z=t(a,v())if not Z then return elseif Z.T==1 then return k(Z.D)else local _=Z.T==2 and&quot;break&quot;or&quot;continue&quot;m(&quot;You tried to &quot;.._..&quot; when not in a loop and look at where that landed you. Go think about your actions.&quot;)end end end)]===]</ProtectedString>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
	</Item>
</roblox>